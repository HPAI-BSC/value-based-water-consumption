households-own [
  density
  income-type income
  own-swimming-pool
  behaviour
  
  
  base-consumptions   weekly-consumptions
  month-consumption   
  members
  ; value-based paper related stuff
  town
  num-visitors
  
  ; variables that stores the data of all household members; some of them are the basic unit to be stored in the weekly lists
  
  ; Household level                      ; Individual level
  contexts                               ; uses the same
  value-order                            members-value-orders
  importances                            members-importances
  actual-value-order                     members-actual-value-orders
  actual-importances                     members-actual-importances
  shifted                                members-shifted
  visitor-shifted                        members-visitor-shifted
  town-shifted                           members-town-shifted
  ; Following variables are local for household level or directly stored in the corresponding weekly list
                                         members-total-shower-units
                                         members-long-showers-micro
                                         members-short-showers-micro
                                         members-water-consumed
                                         members-efforts
  ; these are not used at household level
                                         visitors-context 
                                         visitors-importances  
  
  ; This is to record results; stores the data generated by household for every week. Depending on the execution level, sometimes store a single value or a list of single values
  weekly-actual-values
  weekly-actual-importances
  weekly-shifts
  weekly-visitor-shifted
  weekly-town-shifted
  weekly-shower-units
  weekly-long-showers-micro
  weekly-short-showers-micro
  weekly-water-consumed
  weekly-actual-values-visitors
  weekly-num-visitors
  weekly-town-context
  weekly-visitors-context
  weekly-efforts
]


to-report compute-change-effort [init target init-importances]
  let effort 0
  let new-importances []
  let res []
  
  set new-importances (lput (item (position (item 0 target) init) init-importances) new-importances)
  set new-importances (lput (item (position (item 1 target) init) init-importances) new-importances)
  set new-importances (lput (item (position (item 2 target) init) init-importances) new-importances)
  let Vi (item 0 init-importances)
  let Vj (item 1 init-importances)
  let Vk (item 2 init-importances)
  
  let whereVi (position (item 0 init) target)
  let whereVj (position (item 1 init) target)
  let whereVk (position (item 2 init) target)
  let A (item 0 new-importances)
  let B (item 1 new-importances)
  let C (item 2 new-importances) 
  let AB abs(A - B)
  let AC abs(A - C)
  let BC abs(B - C)
  ; Golden ratio proportion; Take into account that if proportionality is changed, the equations 
  ; in proposal document may vary as well for some cases and the following ifelse should be modified
  ; accordingly.
  let w3 1
  let w2 1.618
  let w1 2.671
  ; There are 6 possible cases depending on where the highest importance is located (and where the second is)
  ; First position in new-importances is A, second B and third C.
  
  (ifelse
    whereVi = 0 and whereVj = 1 [set res (list 0 new-importances)]; original case, nothing to do
    whereVi = 0 and whereVj = 2 [set res (list (BC * w3) (list Vi Vj Vj))] ; Vi Vk Vj
    whereVi = 1 and whereVj = 0 [set res (list (AB * w2) (list Vi Vi Vk))] ; Vj Vi Vk
    whereVi = 1 and whereVj = 2 [set res (list (AB * w3) (list Vi Vi Vj))] ; Vk Vi Vj
    whereVi = 2 and whereVj = 0 [set res (list ((AC * w2) + (BC * w3)) (list Vi Vi Vi))] ; Vj Vk Vi
    whereVi = 2 and whereVj = 1 [set res (list ((AC * w3) + (BC * w2)) (list Vi Vi Vi))] ; Vk Vj Vi
      ;(ifelse ((AC * w3) + (BC * w2)) <= ((AC * w1) + (AB * w2)) [set res (list ((AC * w3) + (BC * w2)) (list Vi Vi Vi))] [set res (list ((AC * w1) + (AB * w2)) (list Vj Vj Vj))])
  )
  ; Returns a list containing the effort of changing the agent's original context to target one in first position. 
  ; Next position contains a list with the changed importance values in the target context so they are consistent 
  ; with conditions and resulting of doing the effort to change to target.
  if debug [print (word "A: " A " B: " B " C: " C " AB: " AB " BC: " BC " AC: " AC " res: " res)]
  report res
end

to-report bernoulli [p]
  report (random-float 1 < p)
end

to-report logistic [x]
  ; 0.05 to reduce sharpness of the curve. Empirically obtained
  report 1 / (1 + exp (-0.05 * x))
end

to-report binomial [n p]
  let success 0
  repeat n [if (bernoulli p) [set success (success + 1)]]
  report success
end

to-report amount-visitors-week [imp-r imp-c]
  report (binomial limit-visitors-week (logistic (imp-r - imp-c)))
end

to-report should-I-shower [imp-e imp-c]
  let shower-units 0
  (ifelse 
    imp-e > imp-c [ ; Environmentalism is first decision making priority
      if (bernoulli ((100 - imp-e) / 100)) 
      [(ifelse (bernoulli (((imp-e - imp-c) / 100) + 0.5)) 
          [set shower-units 1] ; Environmentalism beats comfort
          [set shower-units 3]) ; Comfort beats environmentalism
      ] ; shower despite environmentalism
      ; else shower-units 0, set at the beginning
    ]
    imp-e < imp-c [ ; Comfort is first decision making priority
      (ifelse 
        (bernoulli (imp-c / 100)) [set shower-units 3] ; Comfort wins out shower making decision
        [(ifelse (bernoulli (((imp-c - imp-e) / 100) + 0.5)) [set shower-units 1] ; Comfort beats environmentalism
          ; else shower-units 0, set at the beginning ; Environmentalism beats comfort
          )
      ])]
    [set shower-units 1]) ; Indifferent->normal shower
  report shower-units
end


to first-prototype []
  let choice value-order
  if toggle_visitors [
    set num-visitors random(3)
    if num-visitors > 0 [set choice one-of ["E" "C"]] ; We prioritze always visitors' values over household's ones.    
  ]
  set actual-value-order choice
  
  ; for GUI purposes
  (ifelse actual-value-order = "E" [set color green]
    [set color red])
  set size (3 + num-visitors)
  set shifted (actual-value-order != value-order)
  
  let short-shower (item 0 base-consumptions)
  let long-shower (short-shower * 2.5) ; we could parametrise how many short-showers is a long-shower equivalent
  let no-shower 0
  set weekly-consumptions (map [x -> x + (short-shower * (members + num-visitors))] weekly-consumptions) ; showers everyday for everybody
  let long-showers-micro 0
  ; Generate microbehaviours (e.g., doing sports)
  repeat (members + num-visitors) [
    let aux random-float(1)
    
    let indexes [0 1 2 3 4 5 6]
    (ifelse
      aux >= 0.3 and aux < 0.7
      [let ind one-of indexes
        set indexes remove ind indexes
        set weekly-consumptions (replace-item ind weekly-consumptions ((item ind weekly-consumptions) - short-shower + long-shower))
        set long-showers-micro (long-showers-micro + 1)
      ]
      aux >= 0.7 [
        let ind one-of indexes
        set indexes remove ind indexes
        let ind2 one-of indexes
        set indexes remove ind2 indexes
        set weekly-consumptions (replace-item ind weekly-consumptions ((item ind weekly-consumptions) - short-shower + long-shower))
        set weekly-consumptions (replace-item ind2 weekly-consumptions ((item ind2 weekly-consumptions) - short-shower + long-shower))
        set long-showers-micro (long-showers-micro + 2)
    ])
    ; Now we apply values
    let ind one-of indexes
    (ifelse
      actual-value-order = "E" [set weekly-consumptions (replace-item ind weekly-consumptions ((item ind weekly-consumptions) - short-shower + no-shower))]
      actual-value-order = "C" [set weekly-consumptions (replace-item ind weekly-consumptions ((item ind weekly-consumptions) - short-shower + long-shower))])
  ]
  
  set weekly-shifts (lput shifted weekly-shifts)
  set weekly-water-consumed (lput sum weekly-consumptions weekly-water-consumed)
  set weekly-num-visitors (lput num-visitors weekly-num-visitors)
  set weekly-actual-values (lput actual-value-order weekly-actual-values)
  set weekly-long-showers-micro (lput long-showers-micro weekly-long-showers-micro)

end

to households-version []
  set contexts []
  
  if toggle_visitors [
    set num-visitors (amount-visitors-week (item (position "R" value-order) importances) (item (position "C" value-order) importances))
    (ifelse 
      num-visitors > 0 [
        let aux-ctxt one-of profiles
        set weekly-visitors-context (lput aux-ctxt weekly-visitors-context)
        set contexts (lput aux-ctxt contexts)]
      [set weekly-visitors-context (lput "" weekly-visitors-context)]) 
  ]
  (ifelse 
    toggle_town_context and season = "summer" and town = 1 
    [
    set contexts (lput town-context contexts)
    set weekly-town-context (lput town-context weekly-town-context)] ; we assume only town 1 changes context in Summer
    [set weekly-town-context (lput "" weekly-town-context)])
  
  let current-effort (10000 + effort-threshold) ; Any big number in absence of infinity
  let idx 0
  while [idx < (length contexts)][
    let result (compute-change-effort value-order (item idx contexts) importances)
    if current-effort > (first result) [
      set current-effort (first result)
      set actual-value-order (item idx contexts)
      set actual-importances (last result)]
    set idx (idx + 1)]
  if (current-effort > effort-threshold) or (current-effort = 0)[
    set actual-value-order value-order
    set actual-importances importances
    set current-effort 0 ; We have not moved our value order
  ]
  
  ; for GUI purposes
  set size (3 + num-visitors)
  set shifted (actual-value-order != value-order)
  set color (value-order-to-color actual-value-order)
  set shape (value-order-to-shape value-order)
  if shifted [set shape "star"]
  
  let total-shower-units 0
  let long-showers-micro 0
  let short-showers-micro 0
  
  repeat members + num-visitors[
    set idx 0
    while [idx < 7][ ; for every day
      let shower-units (should-I-shower (item (position "E" actual-value-order) actual-importances) (item (position "C" actual-value-order) actual-importances))
      ; micro-behaviour
      if bernoulli(sporty-probability) [
        (ifelse shower-units = 1 [
          set shower-units 3
          set long-showers-micro (long-showers-micro + 1)
          ]
          shower-units = 0 [
            set shower-units 1
            set short-showers-micro (short-showers-micro + 1)
        ])
        ; we do not increase the kind of shower because of micro-behaviour
      ]
      
      set weekly-consumptions replace-item idx weekly-consumptions ((item idx weekly-consumptions) + (shower-units * (item 0 base-consumptions)))
      set total-shower-units (total-shower-units + shower-units)
      set idx (idx + 1)
    ]
  ]
  set weekly-efforts (lput current-effort weekly-efforts)
  set weekly-shifts (lput shifted weekly-shifts)
  set weekly-water-consumed (lput (total-shower-units * (item 0 base-consumptions)) weekly-water-consumed)
  set weekly-shower-units (lput total-shower-units weekly-shower-units)
  set weekly-num-visitors (lput num-visitors weekly-num-visitors)
  set weekly-actual-values (lput actual-value-order weekly-actual-values)
  set weekly-actual-importances (lput actual-importances  weekly-actual-importances)
  set weekly-long-showers-micro (lput long-showers-micro weekly-long-showers-micro)
  set weekly-short-showers-micro (lput short-showers-micro weekly-short-showers-micro)
end


to-report get-maximum [list-value-orders list-importances value-letter]
  let maximums []
  let idx 0
  while [idx < length list-value-orders][
    let order (item idx list-value-orders)
    let imp (item idx list-importances)
    set maximums (lput (item (position value-letter order) imp) maximums)
    set idx (idx + 1)
  ]
  report max maximums
end

to indi-version []
  set members-actual-value-orders members-value-orders
  set members-actual-importances members-importances
  set members-shifted []
  set members-efforts []
  set contexts []
  
  let idx-members 0
  
  ; Checks if the simulation has visitors. 
  ; If so, we determine if this week there is any visitor, generates their value order and importances.
  ; In any case we store the data in weekly-visitors-context for output (even if there are no visitors, we store "").
  (ifelse 
    toggle_visitors [
      set num-visitors (amount-visitors-week (get-maximum members-value-orders members-importances "R") (get-maximum members-value-orders members-importances "C"))
      (ifelse 
        num-visitors > 0 [
          set visitors-context one-of profiles
          set weekly-visitors-context (lput visitors-context weekly-visitors-context)
          set visitors-importances (generate-importances visitors-context)
          set contexts (lput visitors-context contexts)
        ]
        [set weekly-visitors-context (lput "" weekly-visitors-context)])]
    [set weekly-visitors-context (lput "" weekly-visitors-context)])
  
  ; If we enabled town context, it is summer and 'this' household belongs to town 1. Notice we store "" otherwise for output purposes.
  (ifelse 
    toggle_town_context and season = "summer" and town = 1 [
      set weekly-town-context (lput town-context weekly-town-context)
      set contexts (lput town-context contexts)]
    [set weekly-town-context (lput "" weekly-town-context)])
  
  
  ; We traverse all the members of the household
  ; We start by establishing the original value order and importances of current member as the actual ones for this week.
  ; We set up the effort to "infinity" (so we can update when checking the parallel context that apply this week).
  ; Then we traverse the parallel context (visitors and town)
  ; We determine the effort that the current member should do to change from his/her original context to the current parallel context being treated
  ; If the current effort is higher than the one obtained, we just replace current-effort, the value order and importances.
  ; In this way we get the parallel context that requires less effort. We do not use the original context from the member as part of the
  ; parallel contexts; that one is always at effort 0 and, therefore, member would never change. We assume, therefore, individuals will always seek
  ; to change context to a one that requires less effort that is different from the original they have.
  ; At the end, we check if the effort required (current-effort) is less or equal than the effort-threshold (model parameter). If not, we set as actual
  ; value order and importance, the original ones.
  set idx-members 0
  while [idx-members < members][
    let current-value-order (item idx-members members-value-orders)
    let current-importances (item idx-members members-importances)
    let current-effort (10000 + effort-threshold) ; Any big number in absence of infinity
    ;print(word idx-members " " current-value-order " " current-importances " " current-contexts " " current-effort)
    let idx 0
    while [idx < (length contexts)][
      let result (compute-change-effort current-value-order (item idx contexts) current-importances)
      if current-effort > (first result) [
        set current-effort (first result)
        set members-actual-value-orders (replace-item idx-members members-actual-value-orders (item idx contexts))
        set members-actual-importances (replace-item idx-members members-actual-importances (last result))]
      set idx (idx + 1)
    ]
    if current-effort > effort-threshold [
      set members-actual-value-orders (replace-item idx-members members-actual-value-orders (item idx-members members-value-orders))
      set members-actual-importances (replace-item idx-members members-actual-importances (item idx-members members-importances))
      set current-effort 0 ; We haven't changed the context
    ]
    
    ; We store data for output: efforts done by each member, if they have actually shifted. We do not consider a member has shifted if they just
    ; 'moved' to a visitors or town context that is the same as the one they had.  
    set members-efforts (lput current-effort members-efforts)
    set members-shifted (lput ((item idx-members members-actual-value-orders) != (item idx-members members-value-orders)) members-shifted)
    ; if debug [print (word "household " who "-" idx-members " " current-effort " " members-actual-value-orders " " members-actual-importances)]
    set idx-members (idx-members + 1)
  ]
  
  ; Variables for output
  set members-total-shower-units []
  set members-long-showers-micro []
  set members-short-showers-micro []
  set members-water-consumed []
  
  ; GUI doesn't matter as long as we don't have a way to aggregate value-orders to decide which shape and color to choose
  ; Once each member has determined which value order and importances are to be used this week, we generate  the corresponding shower units per each member
  set idx-members 0
  while [idx-members < members][
    let current-value-order (item idx-members members-actual-value-orders)
    let current-importances (item idx-members members-actual-importances)
    let total-shower-units 0
    let long-showers-micro 0
    let short-showers-micro 0
    let idx 0
    while [idx < 7][ ; for every day
      let shower-units (should-I-shower (item (position "E" current-value-order) current-importances) (item (position "C" current-value-order) current-importances))
      ; micro-behaviour
      if bernoulli(sporty-probability) [
        (ifelse shower-units = 1 [
          set shower-units 3
          set long-showers-micro (long-showers-micro + 1)
          ]
          shower-units = 0 [
            set shower-units 1
            set short-showers-micro (short-showers-micro + 1)
        ])
        ; we do not increase the kind of shower because of micro-behaviour
      ]
      set weekly-consumptions replace-item idx weekly-consumptions ((item idx weekly-consumptions) + (shower-units * (item 0 base-consumptions)))
      set total-shower-units (total-shower-units + shower-units)
      set idx (idx + 1)
    ]
    set members-total-shower-units (lput total-shower-units members-total-shower-units)
    set members-long-showers-micro (lput long-showers-micro members-long-showers-micro)
    set members-short-showers-micro (lput short-showers-micro members-short-showers-micro)
    set members-water-consumed (lput (total-shower-units * (item 0 base-consumptions)) members-water-consumed)
    set idx-members (idx-members + 1) 
  ]
  
  set weekly-efforts (lput members-efforts weekly-efforts)
  set weekly-shifts (lput members-shifted weekly-shifts)
  set weekly-water-consumed (lput members-water-consumed weekly-water-consumed)
  set weekly-shower-units (lput members-total-shower-units weekly-shower-units)
  set weekly-num-visitors (lput num-visitors weekly-num-visitors)
  set weekly-actual-values (lput members-actual-value-orders weekly-actual-values)
  set weekly-actual-importances (lput members-actual-importances weekly-actual-importances)
  set weekly-long-showers-micro (lput members-long-showers-micro weekly-long-showers-micro)
  set weekly-short-showers-micro (lput members-short-showers-micro weekly-short-showers-micro)
end


to define-consumptions
  ;the distribution of consumptions troughout the week are defined for each household
  ask households[
    set weekly-consumptions [0 0 0 0 0 0 0]
    (ifelse 
      version = "first-prototype" [first-prototype]
      version = "individual" [indi-version]
      version = "household" [households-version])
  ]
end

to update-daily-consumption-per-capita
  let consumptions 0
  let dom (time:get "dayofmonth" current-date)
  ask households[
    set consumptions (consumptions + (month-consumption / members))
  ]
  set per-capita-daily-consumption (precision ((consumptions / dom) / (count households)) 6)
end

to-report update-weekly-consumptions[old-weekly value]
  let d ((time:get "dayofweek" current-date) + 1)
  let new-weekly old-weekly
  repeat (7 - d) [set new-weekly (replace-item d new-weekly ((item d new-weekly) + value))
    set d (d + 1)
  ]
  report new-weekly
end